<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BotNameStringFormat" xml:space="preserve">
    <value>{0}_Gen{1}_Bot{2}</value>
    <comment>Format for naming new bots: 0 = base type, 1 = generation number, 2 = bot index in generation.</comment>
  </data>
  <data name="MethodMustReturnBool" xml:space="preserve">
    <value>The branching method must return a bool.</value>
  </data>
  <data name="MethodParametersMustDeriveFromIParameter" xml:space="preserve">
    <value>The branching method's parameters must derive from IParameter&lt;&gt;.</value>
  </data>
  <data name="NonNullLogClassRequired" xml:space="preserve">
    <value>A non-null log class must be provided.</value>
  </data>
  <data name="MutationRateValidRange" xml:space="preserve">
    <value>The mutation rate must be between 0 and 100 inclusive.</value>
  </data>
  <data name="ElitePercentageValidRange" xml:space="preserve">
    <value>The elite percentage must be between 0 and 100 inclusive.</value>
  </data>
  <data name="RandomBotPercentageValidRange" xml:space="preserve">
    <value>The random bot percentage must be between 0 and 100 inclusive.</value>
  </data>
  <data name="ChromosomeOptimisationReturnedNull" xml:space="preserve">
    <value>Chromosome optimisation returned null.</value>
  </data>
  <data name="GenerationNumberValidRange" xml:space="preserve">
    <value>The generation number must be non-negative.</value>
  </data>
  <data name="BotIndexValidRange" xml:space="preserve">
    <value>The index of a bot must be non-negative.</value>
  </data>
  <data name="TerminalMethodsValidRange" xml:space="preserve">
    <value>At least one candidate terminal method must be provided by the TBot class.</value>
  </data>
  <data name="StarterBotsFitnessReportMustNotBeNull" xml:space="preserve">
    <value>Starter bots must contain valid fitness reports.</value>
  </data>
  <data name="BotsPerGenerationValidRange" xml:space="preserve">
    <value>The number of bots per generation must be greater than zero.</value>
  </data>
  <data name="MaxTreeDepthValidRange" xml:space="preserve">
    <value>The maximum tree depth must be non-negative.</value>
  </data>
  <data name="PreviousGenerationReportsRequired" xml:space="preserve">
    <value>The reports for the prevoius generation must be provided when breeding subsequent generations.</value>
  </data>
  <data name="ValidBotCollectionRequired" xml:space="preserve">
    <value>A valid collection of bots is required.</value>
  </data>
  <data name="ValidBotRequired" xml:space="preserve">
    <value>A valid bot must be provided.</value>
  </data>
  <data name="BotFitnessFunctionRequired" xml:space="preserve">
    <value>A bot fitness evaluation function must be provided.</value>
  </data>
  <data name="BotNameValidRange" xml:space="preserve">
    <value>A bot's name cannot be blank.</value>
  </data>
  <data name="ChromosomeRequired" xml:space="preserve">
    <value>A valid chromose tree must be provided.</value>
  </data>
  <data name="MethodParametersRequired" xml:space="preserve">
    <value>The correct number of parameters must be provided to methods that require them.</value>
  </data>
  <data name="SequenceLengthValidRange">
    <value xml:space="preserve">The sequence length must be positive.</value>
  </data>
  <data name="MethodInfoRequired">
    <value xml:space="preserve">A valid information about the method must be provided.</value>
  </data>
  <data name="MethodMustReturnVoid">
    <value xml:space="preserve">A terminal method must return void.</value>
  </data>
</root>